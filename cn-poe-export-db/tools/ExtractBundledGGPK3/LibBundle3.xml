<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LibBundle3</name>
    </assembly>
    <members>
        <member name="M:LibBundle3.Bundle.#ctor(System.IO.Stream,System.Boolean,LibBundle3.Records.BundleRecord)">
            <param name="stream">Stream of the bundle</param>
            <param name="leaveOpen">If false, close the <paramref name="stream"/> after this instance has been disposed</param>
            <param name="record">Record of this bundle file</param>
        </member>
        <member name="M:LibBundle3.Bundle.ReadData">
            <summary>
            Read the whole data of the bundle
            </summary>
        </member>
        <member name="M:LibBundle3.Bundle.ReadDataAndCache">
            <summary>
            Read the whole data of the bundle and cache the result for <see cref="M:LibBundle3.Bundle.ReadData"/> and <see cref="M:LibBundle3.Bundle.ReadData(System.Int32,System.Int32)"/>
            </summary>
        </member>
        <member name="M:LibBundle3.Bundle.RemoveCache">
            <summary>
            Remove the cache generated by <see cref="M:LibBundle3.Bundle.ReadDataAndCache"/>
            </summary>
        </member>
        <member name="M:LibBundle3.Bundle.ReadData(System.Int32,System.Int32)">
            <summary>
            Read the data with the given offset and length
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:LibBundle3.Bundle.ReadChunks(System.Int32,System.Int32)">
            <summary>
            Read chunks (with size of <see cref="F:LibBundle3.Bundle.Header.chunk_size"/>) start with the chunk with index of <paramref name="start"/> and combine them to a <see cref="T:System.Byte"/>[]
            </summary>
            <param name="start">Index of a chunk</param>
            <param name="count">Number of chunks to read</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:LibBundle3.Bundle.SaveData(System.ReadOnlySpan{System.Byte},LibBundle3.Oodle.CompressionLevel)">
            <summary>
            Save the bundle with new contents
            </summary>
        </member>
        <member name="F:LibBundle3.Index.FuncReadBundle">
            <summary>
            Function to get <see cref="T:LibBundle3.Bundle"/> instance with a <see cref="T:LibBundle3.Records.BundleRecord"/>
            </summary>
        </member>
        <member name="P:LibBundle3.Index.Root">
            <summary>
            Root node of the tree (This will call <see cref="M:LibBundle3.Index.BuildTree(LibBundle3.Index.CreateDirectoryInstance,LibBundle3.Index.CreateFileInstance)"/> with default implementation when first calling).
            You can also implement your custom class and use <see cref="M:LibBundle3.Index.BuildTree(LibBundle3.Index.CreateDirectoryInstance,LibBundle3.Index.CreateFileInstance)"/>.
            </summary>
        </member>
        <member name="M:LibBundle3.Index.BuildTree(LibBundle3.Index.CreateDirectoryInstance,LibBundle3.Index.CreateFileInstance)">
            <summary>
            Build a tree to represent the file and directory structure in bundles.
            You can implement your custom class or just use the default implement by calling <see cref="P:LibBundle3.Index.Root"/>
            </summary>
            <param name="createDirectory">Function to create a instance of <see cref="T:LibBundle3.Nodes.IDirectoryNode"/></param>
            <param name="createFile">Function to create a instance of <see cref="T:LibBundle3.Nodes.IFileNode"/></param>
            <returns>The root node of the tree</returns>
        </member>
        <member name="M:LibBundle3.Index.#ctor(System.String,System.Boolean)">
            <param name="filePath">Path to _.index.bin</param>
            <param name="parsePaths">Whether to parse the file paths in index. <see langword="false"/> to speed up reading but all <see cref="P:LibBundle3.Records.FileRecord.Path"/> in each of <see cref="F:LibBundle3.Index._Files"/> will be <see langword="null"/></param>
        </member>
        <member name="M:LibBundle3.Index.#ctor(System.IO.Stream,System.Boolean,System.Boolean)">
            <param name="stream">Stream of _.index.bin</param>
            <param name="leaveOpen">If false, close the <paramref name="stream"/> after this instance has been disposed</param>
            <param name="parsePaths">Whether to parse the file paths in index. <see langword="false"/> to speed up reading but all <see cref="P:LibBundle3.Records.FileRecord.Path"/> in each of <see cref="F:LibBundle3.Index._Files"/> will be <see langword="null"/></param>
        </member>
        <member name="M:LibBundle3.Index.Save">
            <summary>
            Save the _.index.bin. Call this after any file changed
            </summary>
        </member>
        <member name="M:LibBundle3.Index.Extract(LibBundle3.Nodes.ITreeNode,System.String)">
            <summary>
            Extract files to disk, and skip all files in unavailable bundles
            </summary>
            <param name="node">Node to extract (recursively)</param>
            <param name="pathToSave">Path on disk</param>
        </member>
        <member name="M:LibBundle3.Index.Extract(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Extract files with their path, throw when a file couldn't be found
            </summary>
            <param name="filePaths">Path of files to extract, <see langword="null"/> for all files in <see cref="F:LibBundle3.Index._Files"/></param>
            <returns>KeyValuePairs of path and data of each file</returns>
        </member>
        <member name="M:LibBundle3.Index.Replace(LibBundle3.Nodes.ITreeNode,System.String,System.Boolean)">
            <summary>
            Replace files from disk
            </summary>
            <param name="node">Node to replace (recursively)</param>
            <param name="pathToLoad">Path on disk</param>
            <param name="dontChangeBundle">Whether to force all files to be written to their respective original bundle</param>
        </member>
        <member name="M:LibBundle3.Index.Replace(System.Collections.Generic.IEnumerable{System.String},LibBundle3.Index.FuncGetData,System.Boolean)">
            <summary>
            Replace files with their path, throw when a file couldn't be found
            </summary>
            <param name="filePaths">Path of files to replace, <see langword="null"/> for all files in <see cref="F:LibBundle3.Index._Files"/></param>
            <param name="funcGetDataFromFilePath">For getting new data with the path of the file</param>
            <param name="dontChangeBundle">Whether to force all files to be written to their respective original bundle</param>
        </member>
        <member name="M:LibBundle3.Index.Replace(System.Collections.Generic.IEnumerable{System.IO.Compression.ZipArchiveEntry})">
            <summary>
            Patch with a zip file and ignore its files that couldn't be found
            </summary>
        </member>
        <member name="M:LibBundle3.Index.TryGetFile(System.String,LibBundle3.Records.FileRecord@)">
            <summary>
            Get a FileRecord from its path (This won't cause the tree building),
            The separator of the <paramref name="path"/> must be forward slash '/'
            </summary>
            <returns>Null when not found</returns>
        </member>
        <member name="M:LibBundle3.Index.FindNode(System.String,LibBundle3.Nodes.DirectoryNode)">
            <param name="path">Relative path under <paramref name="root"/></param>
            <param name="root">Node to start searching, or <see langword="null"/> for <see cref="P:LibBundle3.Index.Root"/></param>
            <returns>The node found, or <see langword="null"/> when not found</returns>
        </member>
        <member name="M:LibBundle3.Index.GetSmallestBundle">
            <summary>
            Get an available bundle with smallest uncompressed_size
            </summary>
        </member>
        <member name="M:LibBundle3.Index.RecursiveList(LibBundle3.Nodes.ITreeNode,System.String,System.Collections.Generic.ICollection{LibBundle3.Records.FileRecord},System.Boolean)">
            <param name="node">Node to start recursive</param>
            <param name="path">Path on disk which don't end with a slash</param>
            <param name="list">A collection to save the results</param>
            <param name="createDirectory">Whether to create the directories of the files</param>
        </member>
        <member name="M:LibBundle3.Index.NameHash(System.ReadOnlySpan{System.Char})">
            <summary>
            Get the hash of a file path
            </summary>
        </member>
        <member name="M:LibBundle3.Index.NameHash(System.ReadOnlySpan{System.Byte})">
            <summary>
            Get the hash of a file path,
            <paramref name="utf8Str"/> must be lowercased unless it comes from ggpk before patch 3.21.2
            </summary>
        </member>
        <member name="M:LibBundle3.Index.MurmurHash64A(System.ReadOnlySpan{System.Byte},System.UInt64)">
            <summary>
            Get the hash of a file path, <paramref name="utf8Str"/> must be lowercased
            </summary>
        </member>
        <member name="M:LibBundle3.Index.FNV1a64Hash(System.ReadOnlySpan{System.Byte})">
            <summary>
            Get the hash of a file path with ggpk before patch 3.21.2
            </summary>
        </member>
        <member name="T:LibBundle3.Index.BundleComparer">
            <summary>
            For sorting FileRecords with their bundle
            </summary>
        </member>
        <member name="P:LibBundle3.Nodes.DirectoryNode.DirectoryStart">
            <summary>
            In <see cref="P:LibBundle3.Nodes.DirectoryNode.Children"/> starting from this index is not FileNode but DirectoryNode, or -1 if no DirectoryNode
            </summary>
        </member>
        <member name="T:LibBundle3.Nodes.ITreeNode">
            <summary>
            Do not implement this interface, use <see cref="T:LibBundle3.Nodes.IFileNode"/> and <see cref="T:LibBundle3.Nodes.IDirectoryNode"/> instead
            </summary>
        </member>
        <member name="P:LibBundle3.Nodes.ITreeNode.Parent">
            <summary>
            Parent node of this node, or null if this is the Root node
            </summary>
        </member>
        <member name="M:LibBundle3.Nodes.ITreeNode.GetPath(LibBundle3.Nodes.ITreeNode)">
            <summary>
            Get the absolute path of <paramref name="node"/> in the tree, not starts with '/', and ends with '/' if this is a directory
            </summary>
        </member>
        <member name="F:LibBundle3.Oodle.Compressor.None">
            <summary>
            None = memcpy, pass through uncompressed bytes
            </summary>
        </member>
        <member name="F:LibBundle3.Oodle.Compressor.Kraken">
            <summary>
            Fast decompression and high compression ratios, amazing!
            </summary>
        </member>
        <member name="F:LibBundle3.Oodle.Compressor.Leviathan">
            <summary>
            Leviathan = Kraken's big brother with higher compression, slightly slower decompression.
            </summary>
        </member>
        <member name="F:LibBundle3.Oodle.Compressor.Mermaid">
            <summary>
            Mermaid is between Kraken &amp; Selkie - crazy fast, still decent compression.
            </summary>
        </member>
        <member name="F:LibBundle3.Oodle.Compressor.Selkie">
            <summary>
            Selkie is a super-fast relative of Mermaid.  For maximum decode speed.
            </summary>
        </member>
        <member name="F:LibBundle3.Oodle.Compressor.Hydra">
            <summary>
            Hydra, the many-headed beast = Leviathan, Kraken, Mermaid, or Selkie (see $OodleLZ_About_Hydra)
            </summary>
        </member>
        <member name="T:LibBundle3.Records.DirectoryRecord">
            <summary>
            Currently unused
            </summary>
        </member>
        <member name="M:LibBundle3.Records.FileRecord.Read">
            <summary>
            Read the content of the file
            </summary>
        </member>
        <member name="M:LibBundle3.Records.FileRecord.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            Replace the content of the file and save the <see cref="T:LibBundle3.Index"/>
            </summary>
            <param name="newContent"></param>
        </member>
        <member name="M:LibBundle3.Records.FileRecord.Redirect(LibBundle3.Records.BundleRecord,System.Int32,System.Int32)">
            <summary>
            Redirect the <see cref="T:LibBundle3.Records.FileRecord"/> to another section in specified bundle
            </summary>
        </member>
    </members>
</doc>
